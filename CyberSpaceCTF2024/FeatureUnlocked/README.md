For this challenge, we got:
- URL of the web application
- source code of the web application (it can be found in `sources` folder)

First thing we use to do, when the source code of the application is available, is to find the flag's location and all the references for it.
- in this challenge the flag was located in `flag.txt` file
- references for this file were only in the `Dockerfile` (copying it to the container)
![[Pasted image 20240905171857.png]]
From this knowledge, we know that the flag won't be the part of the application itself. The vulnerability we will look for can be for example Command Injection, SSTI (Server Side Template Injection), XXE (XML eXternal Entity) or so.

From this point, we run the app locally and take a look at the application before going straight to the source code. The home page of the application looks as follows:

![[Pasted image 20240905184919.png]]

As the application says, we clicked the text to whether the **new feature** is available as the challange name is **Feature Unlocked**.

![[Pasted image 20240905173304.png]]

Now, we could head to the source code. We are suppose to access some feature without waiting for a whole week. For that reason, we have to take a closer look for the validation whether the feature is accessible.
As we can see, the countdown for the feature release is at the `/release` endpoint, so we can search for that in the source code of the app.
Source code of the function handling this endpoint is provided below:
![[Pasted image 20240905173658.png]]

As we can see, if GET request for this endpoint contains cookie `access_token`, the application deserialize it using `serializer` and check whether the deserialized value is `"access_granted"`. If so, we are redirected to the feature.

Let's take a look what this `serializer` is:

![[Pasted image 20240905174050.png]]

We can see, that the `serializer` is an `URLSafeTimedSerializer` from `itsdangerous` library. According to my quick google search this library is suppose to serve for *"Various helpers to pass data to untrusted environments and to get it back safe and sound."*:

![[Pasted image 20240905174249.png]]

As we can see, it takes 16 pseudo randomly generated bytes. At the beginning, as we saw the name of the library we thought that there will be a fault in the library that we are suppose to exploit to get the correct token. But this didn't lead me nowhere. So after diving into this rabbit hole, we get back to the source code of the endpoint and realized that whole this time solution was right in front of me.

As we can see in the source code, the application uses some **default validation server**.

```python
DEFAULT_VALIDATION_SERVER = 'http://127.0.0.1:1338'
...
validation_server = DEFAULT_VALIDATION_SERVER
```

And if we set query parameter `debug`, the validation server will be override by the `validation_server` from the preference, which is just Base64 encoded JSON in the cookie named `preferences` as we can see in the `get_preferences` function:

![[Pasted image 20240905175301.png]]

Okay, now we know how to set some kind of validation server, but what is it for? Let's take a look at the rest of the `release` function.

![[Pasted image 20240905175411.png]]

We can see that if server is server is validated by `validate_server` function, we will receive `access_token` cookie. That might be the token with the correct value to get us to the new feature, right?
Okay, let's take a look at the `validate_server` function:

![[Pasted image 20240905175644.png]]

We know that we need the result of the function to be true. For that reason, we need the `date` returned by the `validate_access` function do be greater or equal to `NEW_FEATURE_RELEASE` constant, which is `int(time.time()) + 7 * 24 * 60 * 60`, oof. Okay, we might need some epoch (Unix time) to be really big, so what the `validate_access` does with our server.

![[Pasted image 20240905180034.png]]

Okay, first it gets some public key (`get_pubkey`) from the validation server, then it request it makes GET request to the validation server. 

```python
pubkey = get_pubkey(validation_server)
try:
	response = requests.get(validation_server)
```

After this, it converts server's response to JSON and gets it's value for key `date` and key `signature`:

```python
response.raise_for_status()
data = response.json()
date = data['date'].encode('utf-8')
signature = bytes.fromhex(data['signature'])
```

When this is done is uses DSS (Digital Signature Standard) with gotten public key to verify the `date` value with the `signature` value (signed SHA256 hash of the `date`).
Okay so the validation server is suppose to responted with JSON containing:
- date, which has to be greater or equal to the epoch, when the server started
- DSS signature of this date
Okay, that might be alright. We will need to make some JSON with this content. 
- creating public-private key pair for DSS, that sounds easy
- making the JSON, that sounds alright as well
But first, we have to check, how the server gets the public key. It is described in the `get_pubkey` function:

![[Pasted image 20240905181107.png]]

That's pretty straight forward, it access our server at `/pubkey` endpoint and uses response as the public key. Easy enough.
There are two options from this point:
- if we look more into the source, we can find the source code for this validation server (specifically in `sources/src/validation_server/validation.py`) and modify it to work as we want.  You can have it as a try it Your own, if You want to.
- create this 2 files on our own server by ourselves (that's what we did :))

We created a public-private key pair for DSS and the signed date using Python (code of this script can be found in `prep_server.py`).
Now, when we prepared our server with the script, we had to set preference cookie properly to make the application reach our server. We simply did it by editing cookie in the Burp:

![[Pasted image 20240905182707.png]]

After sending this request, we got the `access_token` cookie from the server and could move on to getting the desired flag.

![[Pasted image 20240905182825.png]]

Now, when we accessed the `/release` endpoint, we got redirected to the `/feature` endpoint. Where the cookie was checked once again:

![[Pasted image 20240905183036.png]]

But now, with the cookie, we could finally access the feature (we **Unlocked Feature**)

![[Pasted image 20240905183143.png]]

When we took a look at the source code of this feature, we immediately saw something odd:

![[Pasted image 20240905183726.png]]

User's input `to_process` is put to the command run, without any sanitization and the output of the command is returned in the response, which means that exploitation should be pretty easy and straight forward.

We just need to access the filesystem to realize the `flag.txt` location without sending the output to the `wc`, which would count number of words. First we send input `lol; ls  #`, which showed us that the flag is  in the current directory:



![[Pasted image 20240905184307.png]]

So we repeated the process with getting the flag, instead of listing the directory (`lol; cat flag.txt #`):

![[Pasted image 20240905184410.png]]
